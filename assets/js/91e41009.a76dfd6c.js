"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[260],{4434(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>g,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"api-reference/ports","title":"Port Interfaces","description":"Complete reference for all GaussFlow port interfaces","source":"@site/docs/api-reference/ports.md","sourceDirName":"api-reference","slug":"/api-reference/ports","permalink":"/onegenui-deep-agents/docs/api-reference/ports","draft":false,"unlisted":false,"editUrl":"https://github.com/giulio-leone/onegenui-deep-agents/tree/main/docs/docs/api-reference/ports.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Port Interfaces","description":"Complete reference for all GaussFlow port interfaces"},"sidebar":"tutorialSidebar","previous":{"title":"Error Handling","permalink":"/onegenui-deep-agents/docs/error-handling"},"next":{"title":"Adapter Classes","permalink":"/onegenui-deep-agents/docs/api-reference/adapters"}}');var o=r(4848),s=r(8453);const i={sidebar_position:6,title:"Port Interfaces",description:"Complete reference for all GaussFlow port interfaces"},a="Port Interfaces",l={},d=[{value:"FilesystemPort",id:"filesystemport",level:2},{value:"MemoryPort",id:"memoryport",level:2},{value:"ModelPort",id:"modelport",level:2},{value:"RuntimePort",id:"runtimeport",level:2},{value:"McpPort",id:"mcpport",level:2},{value:"TokenCounterPort",id:"tokencounterport",level:2},{value:"LearningPort",id:"learningport",level:2},{value:"ValidationPort",id:"validationport",level:2},{value:"TracingPort",id:"tracingport",level:2},{value:"MetricsPort",id:"metricsport",level:2},{value:"LoggingPort",id:"loggingport",level:2},{value:"ConsensusPort",id:"consensusport",level:2},{value:"PluginPort",id:"pluginport",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"port-interfaces",children:"Port Interfaces"})}),"\n",(0,o.jsx)(n.p,{children:"Ports define the contracts for GaussFlow's hexagonal architecture. Implement any port to provide a custom adapter."}),"\n",(0,o.jsx)(n.h2,{id:"filesystemport",children:"FilesystemPort"}),"\n",(0,o.jsxs)(n.p,{children:["File operations with zone-based isolation (",(0,o.jsx)(n.code,{children:"transient"})," or ",(0,o.jsx)(n.code,{children:"persistent"}),")."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface FilesystemPort {\n  read(path: string, zone?: FilesystemZone): Promise<string>;\n  write(path: string, content: string, zone?: FilesystemZone): Promise<void>;\n  exists(path: string, zone?: FilesystemZone): Promise<boolean>;\n  delete(path: string, zone?: FilesystemZone): Promise<void>;\n  list(path: string, options?: ListOptions, zone?: FilesystemZone): Promise<FileEntry[]>;\n  search(pattern: string, options?: SearchOptions, zone?: FilesystemZone): Promise<SearchResult[]>;\n  glob(pattern: string, zone?: FilesystemZone): Promise<string[]>;\n  stat(path: string, zone?: FilesystemZone): Promise<FileStat>;\n  syncToPersistent?(): Promise<void>;\n  clearTransient?(): Promise<void>;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"memoryport",children:"MemoryPort"}),"\n",(0,o.jsx)(n.p,{children:"Persistent state storage for todos, checkpoints, conversations, and metadata."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface MemoryPort {\n  saveTodos(sessionId: string, todos: Todo[]): Promise<void>;\n  loadTodos(sessionId: string): Promise<Todo[]>;\n  saveCheckpoint(sessionId: string, checkpoint: Checkpoint): Promise<void>;\n  loadLatestCheckpoint(sessionId: string): Promise<Checkpoint | null>;\n  listCheckpoints(sessionId: string): Promise<Checkpoint[]>;\n  deleteOldCheckpoints(sessionId: string, keepCount: number): Promise<void>;\n  saveConversation(sessionId: string, messages: Message[]): Promise<void>;\n  loadConversation(sessionId: string): Promise<Message[]>;\n  saveMetadata(sessionId: string, key: string, value: unknown): Promise<void>;\n  loadMetadata<T>(sessionId: string, key: string): Promise<T | null>;\n  deleteMetadata(sessionId: string, key: string): Promise<void>;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"modelport",children:"ModelPort"}),"\n",(0,o.jsx)(n.p,{children:"LLM invocation abstraction."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface ModelPort {\n  getModel(): LanguageModel;\n  getContextWindowSize(): number;\n  getModelId(): string;\n  generate(options: ModelGenerateOptions): Promise<ModelGenerateResult>;\n  generateStream?(options: ModelGenerateOptions): Promise<ModelStreamResult>;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"runtimeport",children:"RuntimePort"}),"\n",(0,o.jsx)(n.p,{children:"Platform-agnostic runtime APIs."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface RuntimePort {\n  randomUUID(): string;\n  fetch(input: string | URL | Request, init?: RequestInit): Promise<Response>;\n  getEnv(key: string): string | undefined;\n  setTimeout(callback: () => void, ms: number): { clear(): void };\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"mcpport",children:"McpPort"}),"\n",(0,o.jsx)(n.p,{children:"MCP server discovery and tool execution."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface McpPort {\n  discoverTools(): Promise<Record<string, McpToolDefinition>>;\n  executeTool(name: string, args: unknown): Promise<McpToolResult>;\n  listServers(): Promise<McpServerInfo[]>;\n  connect(config: McpServerConfig): Promise<void>;\n  disconnect(serverId: string): Promise<void>;\n  closeAll(): Promise<void>;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"tokencounterport",children:"TokenCounterPort"}),"\n",(0,o.jsx)(n.p,{children:"Token counting, budgeting, and cost estimation."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface TokenCounterPort {\n  count(text: string, model?: string): number;\n  countMessages(messages: Message[], model?: string): number;\n  getContextWindowSize(model: string): number;\n  estimateCost(inputTokens: number, outputTokens: number, model: string): number;\n  truncate(text: string, maxTokens: number, model?: string): string;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"learningport",children:"LearningPort"}),"\n",(0,o.jsx)(n.p,{children:"Cross-session learning with user profiles, memories, and shared knowledge."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'interface LearningPort {\n  getProfile(userId: string): Promise<UserProfile | null>;\n  updateProfile(userId: string, updates: Partial<Omit<UserProfile, "userId" | "createdAt">>): Promise<UserProfile>;\n  deleteProfile(userId: string): Promise<void>;\n  addMemory(userId: string, memory: Omit<UserMemoryInput, "id" | "createdAt">): Promise<UserMemory>;\n  getMemories(userId: string, options?: { tags?: string[]; limit?: number; since?: number }): Promise<UserMemory[]>;\n  deleteMemory(userId: string, memoryId: string): Promise<void>;\n  clearMemories(userId: string): Promise<void>;\n  addKnowledge(knowledge: Omit<SharedKnowledgeInput, "id" | "createdAt" | "usageCount">): Promise<SharedKnowledge>;\n  queryKnowledge(query: string, options?: { category?: string; limit?: number }): Promise<SharedKnowledge[]>;\n  incrementKnowledgeUsage(knowledgeId: string): Promise<void>;\n  deleteKnowledge(knowledgeId: string): Promise<void>;\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"validationport",children:"ValidationPort"}),"\n",(0,o.jsx)(n.p,{children:"Engine-agnostic validation contract."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface ValidationPort {\n  validate<T>(schema: unknown, data: unknown): ValidationResult<T>;\n  validateOrThrow<T>(schema: unknown, data: unknown): T;\n}\n\ninterface ValidationResult<T = unknown> {\n  readonly success: boolean;\n  readonly data?: T;\n  readonly error?: string;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"tracingport",children:"TracingPort"}),"\n",(0,o.jsx)(n.p,{children:"Distributed tracing contract."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'interface TracingPort {\n  startSpan(name: string, parentSpan?: Span): Span;\n}\n\ninterface Span {\n  readonly traceId: string;\n  readonly spanId: string;\n  readonly name: string;\n  setAttribute(key: string, value: string | number | boolean): void;\n  setStatus(status: "ok" | "error", message?: string): void;\n  end(): void;\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"metricsport",children:"MetricsPort"}),"\n",(0,o.jsx)(n.p,{children:"Metrics collection contract."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface MetricsPort {\n  incrementCounter(name: string, value?: number, labels?: Record<string, string>): void;\n  recordHistogram(name: string, value: number, labels?: Record<string, string>): void;\n  recordGauge(name: string, value: number, labels?: Record<string, string>): void;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"loggingport",children:"LoggingPort"}),"\n",(0,o.jsx)(n.p,{children:"Structured logging contract."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'type LogLevel = "debug" | "info" | "warn" | "error";\n\ninterface LoggingPort {\n  log(level: LogLevel, message: string, context?: Record<string, unknown>): void;\n  debug(message: string, context?: Record<string, unknown>): void;\n  info(message: string, context?: Record<string, unknown>): void;\n  warn(message: string, context?: Record<string, unknown>): void;\n  error(message: string, context?: Record<string, unknown>): void;\n}\n\ninterface LogEntry {\n  readonly level: LogLevel;\n  readonly message: string;\n  readonly timestamp: number;\n  readonly context?: Record<string, unknown>;\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"consensusport",children:"ConsensusPort"}),"\n",(0,o.jsx)(n.p,{children:"Strategy for evaluating fork results in AgentGraph."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface ConsensusPort {\n  evaluate(results: Array<{ id: string; output: string }>): Promise<ConsensusResult>;\n}\n\ninterface ConsensusResult {\n  winnerId: string;\n  winnerOutput: string;\n  scores?: Record<string, number>;\n  merged?: string;\n  reasoning?: string;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"pluginport",children:"PluginPort"}),"\n",(0,o.jsx)(n.p,{children:"Plugin contracts and lifecycle hooks."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface DeepAgentPlugin {\n  readonly name: string;\n  readonly version?: string;\n  readonly hooks?: PluginHooks;\n  readonly tools?: Record<string, Tool>;\n  setup?(ctx: PluginSetupContext): Promise<void> | void;\n  dispose?(): Promise<void> | void;\n}\n\ninterface PluginHooks {\n  beforeRun?(ctx: PluginContext, params: BeforeRunParams): Promise<BeforeRunResult | void>;\n  afterRun?(ctx: PluginContext, params: AfterRunParams): Promise<void>;\n  beforeTool?(ctx: PluginContext, params: BeforeToolParams): Promise<BeforeToolResult | void>;\n  afterTool?(ctx: PluginContext, params: AfterToolParams): Promise<void>;\n  beforeStep?(ctx: PluginContext, params: BeforeStepParams): Promise<BeforeStepResult | void>;\n  afterStep?(ctx: PluginContext, params: AfterStepParams): Promise<void>;\n  onError?(ctx: PluginContext, params: OnErrorParams): Promise<OnErrorResult | void>;\n}\n\ninterface PluginContext {\n  readonly sessionId: string;\n  readonly agentName?: string;\n  readonly config: Readonly<{ instructions: string; maxSteps: number }>;\n  readonly filesystem: FilesystemPort;\n  readonly memory: MemoryPort;\n  readonly learning?: LearningPort;\n  readonly toolNames: readonly string[];\n  readonly runMetadata?: PluginRunMetadata;\n}\n"})})]})}function g(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453(e,n,r){r.d(n,{R:()=>i,x:()=>a});var t=r(6540);const o={},s=t.createContext(o);function i(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);