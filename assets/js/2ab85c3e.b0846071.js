"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[738],{1445(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"graph/index","title":"AgentGraph","description":"Multi-agent collaboration with DAG execution, forking, and consensus","source":"@site/docs/graph/index.md","sourceDirName":"graph","slug":"/graph/","permalink":"/onegenui-deep-agents/docs/graph/","draft":false,"unlisted":false,"editUrl":"https://github.com/giulio-leone/onegenui-deep-agents/tree/main/docs/docs/graph/index.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"AgentGraph","description":"Multi-agent collaboration with DAG execution, forking, and consensus"},"sidebar":"tutorialSidebar","previous":{"title":"Multi-Runtime Support","permalink":"/onegenui-deep-agents/docs/runtime/"},"next":{"title":"CLI","permalink":"/onegenui-deep-agents/docs/cli"}}');var r=s(4848),d=s(8453);const i={sidebar_position:5,title:"AgentGraph",description:"Multi-agent collaboration with DAG execution, forking, and consensus"},o="AgentGraph",c={},l=[{value:"Quick Start",id:"quick-start",level:2},{value:"Builder API",id:"builder-api",level:2},{value:"<code>AgentGraph.create(config?)</code>",id:"agentgraphcreateconfig",level:3},{value:"<code>.node(id, config)</code>",id:"nodeid-config",level:3},{value:"<code>.edge(from, to)</code>",id:"edgefrom-to",level:3},{value:"<code>.fork(id, configs)</code>",id:"forkid-configs",level:3},{value:"<code>.consensus(forkId, strategy)</code>",id:"consensusforkid-strategy",level:3},{value:"<code>.build()</code>",id:"build",level:3},{value:"Consensus Strategies",id:"consensus-strategies",level:2},{value:"Custom Consensus",id:"custom-consensus",level:3},{value:"Streaming",id:"streaming",level:2},{value:"Stream Event Types",id:"stream-event-types",level:2},{value:"GraphResult",id:"graphresult",level:2},{value:"Validation",id:"validation",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"agentgraph",children:"AgentGraph"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"AgentGraph"})," enables multi-agent collaboration using a declarative DAG (Directed Acyclic Graph) API. Agents are nodes, dependencies are edges, and parallel execution is managed automatically."]}),"\n",(0,r.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { AgentGraph, LlmJudgeConsensus } from "@giulio-leone/gaussflow-agent";\nimport { openai } from "@ai-sdk/openai";\n\nconst model = openai("gpt-4o");\n\nconst graph = AgentGraph.create({ maxConcurrency: 3 })\n  .node("research", {\n    model,\n    instructions: "Research the topic thoroughly.",\n  })\n  .node("code", {\n    model,\n    instructions: "Write clean, tested code.",\n  })\n  .node("test", {\n    model,\n    instructions: "Write comprehensive tests.",\n  })\n  .edge("research", "code")    // code depends on research\n  .edge("code", "test")        // test depends on code\n  .fork("review", [\n    { model, instructions: "Review for correctness and bugs." },\n    { model, instructions: "Review for performance and style." },\n    { model, instructions: "Review for security vulnerabilities." },\n  ])\n  .consensus("review", new LlmJudgeConsensus({ model }))\n  .edge("test", "review")\n  .build();\n\nconst result = await graph.run("Build a REST API with JWT auth.");\nconsole.log(result.output);\nconsole.log(result.nodeResults);      // Per-node results\nconsole.log(result.totalDurationMs);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"builder-api",children:"Builder API"}),"\n",(0,r.jsx)(n.h3,{id:"agentgraphcreateconfig",children:(0,r.jsx)(n.code,{children:"AgentGraph.create(config?)"})}),"\n",(0,r.jsxs)(n.p,{children:["Returns an ",(0,r.jsx)(n.code,{children:"AgentGraphBuilder"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const builder = AgentGraph.create({\n  maxDepth: 10,          // Default: 10\n  maxConcurrency: 5,     // Default: 5\n  timeoutMs: 600_000,    // Default: 600000 (10 min)\n  maxTokenBudget: 1_000_000,  // Default: 1000000\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"nodeid-config",children:(0,r.jsx)(n.code,{children:".node(id, config)"})}),"\n",(0,r.jsx)(n.p,{children:"Add an agent node:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'builder.node("analyst", {\n  model: openai("gpt-4o"),\n  instructions: "You are a data analyst.",\n  maxSteps: 20,\n});\n'})}),"\n",(0,r.jsx)(n.h3,{id:"edgefrom-to",children:(0,r.jsx)(n.code,{children:".edge(from, to)"})}),"\n",(0,r.jsx)(n.p,{children:"Define a dependency (DAG edge):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'builder.edge("research", "analysis"); // analysis runs after research\n'})}),"\n",(0,r.jsx)(n.h3,{id:"forkid-configs",children:(0,r.jsx)(n.code,{children:".fork(id, configs)"})}),"\n",(0,r.jsx)(n.p,{children:"Create a parallel fork (minimum 2 agents):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'builder.fork("review", [\n  { model, instructions: "Review for correctness." },\n  { model, instructions: "Review for performance." },\n]);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"consensusforkid-strategy",children:(0,r.jsx)(n.code,{children:".consensus(forkId, strategy)"})}),"\n",(0,r.jsx)(n.p,{children:"Set a consensus strategy for a fork:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'builder.consensus("review", new LlmJudgeConsensus({ model }));\n'})}),"\n",(0,r.jsx)(n.h3,{id:"build",children:(0,r.jsx)(n.code,{children:".build()"})}),"\n",(0,r.jsxs)(n.p,{children:["Validates the graph (no cycles, all edge targets exist) and constructs the ",(0,r.jsx)(n.code,{children:"AgentGraph"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"consensus-strategies",children:"Consensus Strategies"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Strategy"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"LlmJudgeConsensus"})}),(0,r.jsx)(n.td,{children:"Uses an LLM to evaluate fork results and pick the best"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"MajorityVoteConsensus"})}),(0,r.jsx)(n.td,{children:"Simple majority vote across outputs"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"DebateConsensus"})}),(0,r.jsx)(n.td,{children:"Multi-round debate between outputs"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"custom-consensus",children:"Custom Consensus"}),"\n",(0,r.jsxs)(n.p,{children:["Implement ",(0,r.jsx)(n.code,{children:"ConsensusPort"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import type { ConsensusPort, ConsensusResult } from "@giulio-leone/gaussflow-agent";\n\nclass CustomConsensus implements ConsensusPort {\n  async evaluate(\n    results: Array<{ id: string; output: string }>\n  ): Promise<ConsensusResult> {\n    // Your evaluation logic\n    const winner = results[0];\n    return {\n      winnerId: winner.id,\n      winnerOutput: winner.output,\n      reasoning: "Selected the first result",\n    };\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"streaming",children:"Streaming"}),"\n",(0,r.jsx)(n.p,{children:"Stream graph events in real-time:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'for await (const event of graph.stream("Build a REST API")) {\n  switch (event.type) {\n    case "graph:start":\n      console.log(`Starting graph with ${event.nodeCount} nodes`);\n      break;\n    case "node:start":\n      console.log(`Node ${event.nodeId} started`);\n      break;\n    case "node:complete":\n      console.log(`Node ${event.nodeId} completed in ${event.result.durationMs}ms`);\n      break;\n    case "fork:start":\n      console.log(`Fork ${event.forkId} started with ${event.agentCount} agents`);\n      break;\n    case "consensus:result":\n      console.log(`Consensus for ${event.forkId}: ${event.output}`);\n      break;\n    case "graph:complete":\n      console.log(`Graph completed in ${event.result.totalDurationMs}ms`);\n      break;\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"stream-event-types",children:"Stream Event Types"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Event"}),(0,r.jsx)(n.th,{children:"Fields"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"graph:start"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"nodeCount"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"node:start"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"nodeId"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"node:complete"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"nodeId"}),", ",(0,r.jsx)(n.code,{children:"result"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"node:error"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"nodeId"}),", ",(0,r.jsx)(n.code,{children:"error"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"fork:start"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"forkId"}),", ",(0,r.jsx)(n.code,{children:"agentCount"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"fork:complete"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"forkId"}),", ",(0,r.jsx)(n.code,{children:"results"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"consensus:start"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"forkId"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"consensus:result"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"forkId"}),", ",(0,r.jsx)(n.code,{children:"output"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"graph:complete"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"result"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"graph:error"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"error"}),", ",(0,r.jsx)(n.code,{children:"partialResults"})]})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"graphresult",children:"GraphResult"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface GraphResult {\n  output: string;                                    // Final output\n  nodeResults: Record<string, NodeResultValue>;      // Per-node results\n  totalDurationMs: number;\n  totalTokenUsage: { input: number; output: number };\n}\n\ninterface NodeResultValue {\n  nodeId: string;\n  output: string;\n  tokenUsage?: { input: number; output: number };\n  durationMs: number;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"validation",children:"Validation"}),"\n",(0,r.jsx)(n.p,{children:"The builder automatically validates:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Edge targets exist"})," \u2014 All nodes referenced in edges must be defined"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No cycles"})," \u2014 The graph must be a DAG (Directed Acyclic Graph)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fork minimum"})," \u2014 Forks require at least 2 agent configurations"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453(e,n,s){s.d(n,{R:()=>i,x:()=>o});var t=s(6540);const r={},d=t.createContext(r);function i(e){const n=t.useContext(d);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(d.Provider,{value:n},e.children)}}}]);