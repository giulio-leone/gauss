"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[571],{4148(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"resilience","title":"Resilience Patterns","description":"Circuit breaker, rate limiter, and tool cache for robust agent operations","source":"@site/docs/resilience.md","sourceDirName":".","slug":"/resilience","permalink":"/onegenui-deep-agents/docs/resilience","draft":false,"unlisted":false,"editUrl":"https://github.com/giulio-leone/onegenui-deep-agents/tree/main/docs/docs/resilience.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8,"title":"Resilience Patterns","description":"Circuit breaker, rate limiter, and tool cache for robust agent operations"},"sidebar":"tutorialSidebar","previous":{"title":"CLI","permalink":"/onegenui-deep-agents/docs/cli"},"next":{"title":"REST API","permalink":"/onegenui-deep-agents/docs/rest-api"}}');var r=t(4848),a=t(8453);const s={sidebar_position:8,title:"Resilience Patterns",description:"Circuit breaker, rate limiter, and tool cache for robust agent operations"},l="Resilience Patterns",o={},c=[{value:"Circuit Breaker",id:"circuit-breaker",level:2},{value:"Configuration",id:"configuration",level:3},{value:"States",id:"states",level:3},{value:"Usage with DeepAgent",id:"usage-with-deepagent",level:3},{value:"Manual Circuit Breaker Usage",id:"manual-circuit-breaker-usage",level:3},{value:"Rate Limiter",id:"rate-limiter",level:2},{value:"Configuration",id:"configuration-1",level:3},{value:"Usage with DeepAgent",id:"usage-with-deepagent-1",level:3},{value:"Manual Rate Limiter Usage",id:"manual-rate-limiter-usage",level:3},{value:"Backpressure Handling",id:"backpressure-handling",level:3},{value:"Tool Cache",id:"tool-cache",level:2},{value:"Configuration",id:"configuration-2",level:3},{value:"Usage with DeepAgent",id:"usage-with-deepagent-2",level:3},{value:"Manual Tool Cache Usage",id:"manual-tool-cache-usage",level:3},{value:"Cache Key Generation",id:"cache-key-generation",level:3},{value:"Combining Resilience Patterns",id:"combining-resilience-patterns",level:2},{value:"Error Handling with Resilience",id:"error-handling-with-resilience",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Circuit Breaker",id:"circuit-breaker-1",level:3},{value:"Rate Limiter",id:"rate-limiter-1",level:3},{value:"Tool Cache",id:"tool-cache-1",level:3},{value:"Monitoring",id:"monitoring",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"resilience-patterns",children:"Resilience Patterns"})}),"\n",(0,r.jsx)(n.p,{children:"GaussFlow provides built-in resilience patterns to handle failures, rate limits, and performance optimization. These patterns help create robust, production-ready agents that can handle various failure modes gracefully."}),"\n",(0,r.jsx)(n.h2,{id:"circuit-breaker",children:"Circuit Breaker"}),"\n",(0,r.jsx)(n.p,{children:'The circuit breaker pattern prevents cascading failures by temporarily blocking operations that are likely to fail. It monitors failure rates and automatically "opens" when failures exceed a threshold.'}),"\n",(0,r.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { CircuitBreaker, DEFAULT_CIRCUIT_BREAKER_CONFIG } from "@giulio-leone/gaussflow-agent";\n\nconst circuitBreaker = new CircuitBreaker({\n  failureThreshold: 5,        // Open after 5 consecutive failures\n  resetTimeoutMs: 30_000,     // Wait 30 seconds before trying again\n  monitorWindowMs: 60_000,    // Track failures over 1 minute window\n});\n\n// Default configuration\nconst defaultBreaker = new CircuitBreaker(DEFAULT_CIRCUIT_BREAKER_CONFIG);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"states",children:"States"}),"\n",(0,r.jsx)(n.p,{children:"The circuit breaker has three states:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"State"}),(0,r.jsx)(n.th,{children:"Description"}),(0,r.jsx)(n.th,{children:"Behavior"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"CLOSED"})}),(0,r.jsx)(n.td,{children:"Normal operation"}),(0,r.jsx)(n.td,{children:"All requests pass through"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"OPEN"})}),(0,r.jsx)(n.td,{children:"Failing fast"}),(0,r.jsx)(n.td,{children:"All requests rejected immediately"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"HALF_OPEN"})}),(0,r.jsx)(n.td,{children:"Testing recovery"}),(0,r.jsx)(n.td,{children:"Limited requests allowed to test service health"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"usage-with-deepagent",children:"Usage with DeepAgent"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { DeepAgent, CircuitBreaker } from "@giulio-leone/gaussflow-agent";\nimport { openai } from "@ai-sdk/openai";\n\nconst circuitBreaker = new CircuitBreaker({\n  failureThreshold: 3,\n  resetTimeoutMs: 15_000,\n  monitorWindowMs: 30_000,\n});\n\nconst agent = DeepAgent.create({\n  model: openai("gpt-4o"),\n  instructions: "You are a resilient assistant that handles failures gracefully.",\n})\n  .withCircuitBreaker(circuitBreaker)\n  .withPlanning()\n  .build();\n\ntry {\n  const result = await agent.run("Process this data safely.");\n  console.log("Success:", result.text);\n} catch (error) {\n  if (error.message.includes("Circuit breaker is OPEN")) {\n    console.log("Service temporarily unavailable, trying again later...");\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"manual-circuit-breaker-usage",children:"Manual Circuit Breaker Usage"}),"\n",(0,r.jsx)(n.p,{children:"You can also use the circuit breaker directly for custom operations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const breaker = new CircuitBreaker({ failureThreshold: 3 });\n\nasync function makeApiCall() {\n  return await breaker.execute(async () => {\n    const response = await fetch("https://api.example.com/data");\n    if (!response.ok) {\n      throw new Error(`API failed with status ${response.status}`);\n    }\n    return response.json();\n  });\n}\n\n// Check circuit breaker state\nconsole.log("Circuit state:", breaker.getState());\nconsole.log("Failure count:", breaker.getFailureCount());\n'})}),"\n",(0,r.jsx)(n.h2,{id:"rate-limiter",children:"Rate Limiter"}),"\n",(0,r.jsx)(n.p,{children:"The rate limiter controls the frequency of operations using a token bucket algorithm. This helps prevent overwhelming external services and ensures fair resource usage."}),"\n",(0,r.jsx)(n.h3,{id:"configuration-1",children:"Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { RateLimiter, DEFAULT_RATE_LIMITER_CONFIG } from "@giulio-leone/gaussflow-agent";\n\nconst rateLimiter = new RateLimiter({\n  maxTokens: 10,              // Maximum 10 tokens in bucket\n  refillRateMs: 1000,         // Add 1 token every 1000ms (1 per second)\n});\n\n// Default configuration (10 tokens, 1 per second)\nconst defaultLimiter = new RateLimiter(DEFAULT_RATE_LIMITER_CONFIG);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"usage-with-deepagent-1",children:"Usage with DeepAgent"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { DeepAgent, RateLimiter } from "@giulio-leone/gaussflow-agent";\nimport { openai } from "@ai-sdk/openai";\n\nconst rateLimiter = new RateLimiter({\n  maxTokens: 5,               // 5 requests burst capacity\n  refillRateMs: 2000,         // 1 token every 2 seconds\n});\n\nconst agent = DeepAgent.create({\n  model: openai("gpt-4o"),\n  instructions: "You are a rate-limited assistant.",\n})\n  .withRateLimiter(rateLimiter)\n  .withPlanning()\n  .build();\n\n// Tool executions are automatically rate-limited\nconst result = await agent.run("Make multiple API calls at controlled rate.");\n'})}),"\n",(0,r.jsx)(n.h3,{id:"manual-rate-limiter-usage",children:"Manual Rate Limiter Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const limiter = new RateLimiter({ maxTokens: 3, refillRateMs: 1000 });\n\nasync function rateLimitedOperation() {\n  // Wait for token availability\n  await limiter.acquire();\n  \n  // Perform the operation\n  console.log("Operation executed at:", new Date().toISOString());\n  return fetch("https://api.example.com/endpoint");\n}\n\n// Try immediate acquisition\nif (limiter.tryAcquire()) {\n  console.log("Token acquired immediately");\n} else {\n  console.log("No tokens available, would need to wait");\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"backpressure-handling",children:"Backpressure Handling"}),"\n",(0,r.jsx)(n.p,{children:"The rate limiter automatically handles backpressure by queuing requests when tokens are not available:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const limiter = new RateLimiter({ maxTokens: 2, refillRateMs: 1000 });\n\n// Multiple concurrent requests will be queued and processed at the configured rate\nconst promises = Array.from({ length: 5 }, (_, i) =>\n  limiter.acquire().then(() => console.log(`Request ${i} processed`))\n);\n\nawait Promise.all(promises);\n// Output will show requests processed at 1-second intervals\n"})}),"\n",(0,r.jsx)(n.h2,{id:"tool-cache",children:"Tool Cache"}),"\n",(0,r.jsx)(n.p,{children:"The tool cache provides LRU (Least Recently Used) caching with TTL (Time To Live) support for tool execution results. This improves performance by avoiding redundant expensive operations."}),"\n",(0,r.jsx)(n.h3,{id:"configuration-2",children:"Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { ToolCache, DEFAULT_TOOL_CACHE_CONFIG } from "@giulio-leone/gaussflow-agent";\n\nconst toolCache = new ToolCache({\n  defaultTtlMs: 300_000,      // 5 minute default TTL\n  maxSize: 1000,              // Maximum 1000 cache entries\n});\n\n// Default configuration (5 minutes TTL, 1000 entries)\nconst defaultCache = new ToolCache(DEFAULT_TOOL_CACHE_CONFIG);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"usage-with-deepagent-2",children:"Usage with DeepAgent"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { DeepAgent, ToolCache } from "@giulio-leone/gaussflow-agent";\nimport { openai } from "@ai-sdk/openai";\n\nconst toolCache = new ToolCache({\n  defaultTtlMs: 600_000,      // 10 minute cache\n  maxSize: 500,               // 500 cache entries\n});\n\nconst agent = DeepAgent.create({\n  model: openai("gpt-4o"),\n  instructions: "You are an efficient assistant that caches expensive operations.",\n})\n  .withToolCache(toolCache)\n  .withPlanning()\n  .build();\n\n// Identical tool calls will return cached results\nconst result1 = await agent.run("Analyze this complex data set.");\nconst result2 = await agent.run("Analyze this complex data set."); // Returns cached result\n'})}),"\n",(0,r.jsx)(n.h3,{id:"manual-tool-cache-usage",children:"Manual Tool Cache Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const cache = new ToolCache({ defaultTtlMs: 300_000, maxSize: 100 });\n\n// Store with default TTL\ncache.set("expensive-operation", { result: "computed value" });\n\n// Store with custom TTL (1 hour)\ncache.set("long-lived-data", { data: "important" }, 3600_000);\n\n// Retrieve cached values\nconst cached = cache.get("expensive-operation");\nif (cached) {\n  console.log("Cache hit:", cached);\n} else {\n  console.log("Cache miss, need to recompute");\n}\n\n// Check cache stats\nconsole.log("Cache stats:", cache.getStats());\n// Output: { size: 2, hits: 1, misses: 0, hitRate: 1 }\n\n// Clear cache\ncache.clear();\n'})}),"\n",(0,r.jsx)(n.h3,{id:"cache-key-generation",children:"Cache Key Generation"}),"\n",(0,r.jsx)(n.p,{children:"The tool cache automatically generates cache keys based on tool name and parameters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// These would have different cache keys:\n// - read_file("/path/to/file1.txt")\n// - read_file("/path/to/file2.txt")\n// - write_file("/path/to/file1.txt", "content")\n\n// These would have the same cache key (and return cached result):\n// - read_file("/path/to/file1.txt") \n// - read_file("/path/to/file1.txt") // Cache hit\n'})}),"\n",(0,r.jsx)(n.h2,{id:"combining-resilience-patterns",children:"Combining Resilience Patterns"}),"\n",(0,r.jsx)(n.p,{children:"For maximum robustness, combine all three patterns:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { \n  DeepAgent, \n  CircuitBreaker, \n  RateLimiter, \n  ToolCache \n} from "@giulio-leone/gaussflow-agent";\nimport { openai } from "@ai-sdk/openai";\n\nconst agent = DeepAgent.create({\n  model: openai("gpt-4o"),\n  instructions: "You are a highly resilient assistant with comprehensive failure handling.",\n})\n  .withCircuitBreaker(new CircuitBreaker({\n    failureThreshold: 3,\n    resetTimeoutMs: 30_000,\n    monitorWindowMs: 60_000,\n  }))\n  .withRateLimiter(new RateLimiter({\n    maxTokens: 5,\n    refillRateMs: 2000,\n  }))\n  .withToolCache(new ToolCache({\n    defaultTtlMs: 600_000,\n    maxSize: 1000,\n  }))\n  .withPlanning()\n  .build();\n\n// This agent will:\n// 1. Cache tool results to avoid redundant work\n// 2. Rate limit tool executions to prevent overwhelming services\n// 3. Circuit break on repeated failures to prevent cascading issues\nconst result = await agent.run("Process this data with full resilience patterns.");\n'})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling-with-resilience",children:"Error Handling with Resilience"}),"\n",(0,r.jsx)(n.p,{children:"Resilience patterns integrate with GaussFlow's error handling system:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { \n  DeepAgent, \n  CircuitBreaker, \n  CircuitBreakerError,\n  RateLimiterError \n} from "@giulio-leone/gaussflow-agent";\n\nconst agent = DeepAgent.create({ model, instructions: "..." })\n  .withCircuitBreaker(new CircuitBreaker())\n  .withRateLimiter(new RateLimiter())\n  .on("error", (event) => {\n    const error = event.data;\n    \n    if (error instanceof CircuitBreakerError) {\n      console.log("Circuit breaker blocked operation:", error.message);\n    } else if (error.message.includes("rate limit")) {\n      console.log("Rate limit exceeded, operation queued");\n    }\n  })\n  .build();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"circuit-breaker-1",children:"Circuit Breaker"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Set ",(0,r.jsx)(n.code,{children:"failureThreshold"})," based on your service's expected failure rate"]}),"\n",(0,r.jsxs)(n.li,{children:["Use longer ",(0,r.jsx)(n.code,{children:"resetTimeoutMs"})," for external services that take time to recover"]}),"\n",(0,r.jsx)(n.li,{children:"Monitor circuit breaker state in production to tune parameters"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"rate-limiter-1",children:"Rate Limiter"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Set ",(0,r.jsx)(n.code,{children:"maxTokens"})," to allow reasonable burst traffic"]}),"\n",(0,r.jsxs)(n.li,{children:["Configure ",(0,r.jsx)(n.code,{children:"refillRateMs"})," based on API rate limits or resource constraints"]}),"\n",(0,r.jsx)(n.li,{children:"Consider using separate rate limiters for different operation types"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"tool-cache-1",children:"Tool Cache"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Set ",(0,r.jsx)(n.code,{children:"defaultTtlMs"})," based on how frequently your data changes"]}),"\n",(0,r.jsxs)(n.li,{children:["Monitor cache hit rates and adjust ",(0,r.jsx)(n.code,{children:"maxSize"})," accordingly"]}),"\n",(0,r.jsx)(n.li,{children:"Use shorter TTLs for dynamic data, longer for static reference data"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"monitoring",children:"Monitoring"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"ObservabilityPlugin"})," to track resilience pattern metrics"]}),"\n",(0,r.jsx)(n.li,{children:"Set up alerts for circuit breaker state changes"}),"\n",(0,r.jsx)(n.li,{children:"Monitor cache hit rates and rate limiter queue lengths"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { DeepAgent, ObservabilityPlugin } from "@giulio-leone/gaussflow-agent";\n\nconst observability = new ObservabilityPlugin({\n  metrics: { enabled: true },\n  logging: { level: "info" },\n});\n\nconst agent = DeepAgent.create({ model, instructions: "..." })\n  .withCircuitBreaker(new CircuitBreaker())\n  .withRateLimiter(new RateLimiter())\n  .withToolCache(new ToolCache())\n  .use(observability)\n  .build();\n\n// Metrics automatically collected for resilience patterns\n'})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>s,x:()=>l});var i=t(6540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);